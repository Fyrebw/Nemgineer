using RoR2;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace EntityStates
{
  public class BaseState : EntityState
  {
    protected float attackSpeedStat = 1f;
    protected float damageStat;
    protected float critStat;
    protected float moveSpeedStat;
    private const float defaultAimDuration = 2f;

    public override void OnEnter()
    {
      base.OnEnter();
      if (!(bool) (UnityEngine.Object) this.characterBody)
        return;
      this.attackSpeedStat = this.characterBody.attackSpeed;
      this.damageStat = this.characterBody.damage;
      this.critStat = this.characterBody.crit;
      this.moveSpeedStat = this.characterBody.moveSpeed;
    }

    protected Ray GetAimRay() => (bool) (UnityEngine.Object) this.inputBank ? new Ray(this.inputBank.aimOrigin, this.inputBank.aimDirection) : new Ray(this.transform.position, this.transform.forward);

    protected void AddRecoil(
      float verticalMin,
      float verticalMax,
      float horizontalMin,
      float horizontalMax)
    {
      this.cameraTargetParams.AddRecoil(verticalMin, verticalMax, horizontalMin, horizontalMax);
    }

    public OverlapAttack InitMeleeOverlap(
      float damageCoefficient,
      GameObject hitEffectPrefab,
      Transform modelTransform,
      string hitboxGroupName)
    {
      OverlapAttack overlapAttack = new OverlapAttack()
      {
        attacker = this.gameObject,
        inflictor = this.gameObject
      };
      overlapAttack.teamIndex = TeamComponent.GetObjectTeam(overlapAttack.attacker);
      overlapAttack.damage = damageCoefficient * this.damageStat;
      overlapAttack.hitEffectPrefab = hitEffectPrefab;
      overlapAttack.isCrit = this.RollCrit();
      if ((bool) (UnityEngine.Object) modelTransform)
        overlapAttack.hitBoxGroup = Array.Find<HitBoxGroup>(modelTransform.GetComponents<HitBoxGroup>(), (Predicate<HitBoxGroup>) (element => element.groupName == hitboxGroupName));
      return overlapAttack;
    }

    public bool FireMeleeOverlap(
      OverlapAttack attack,
      Animator animator,
      string mecanimHitboxActiveParameter,
      float forceMagnitude,
      bool calculateForceVector = true)
    {
      bool flag = false;
      if ((bool) (UnityEngine.Object) animator && (double) animator.GetFloat(mecanimHitboxActiveParameter) > 0.10000000149011612)
      {
        if (calculateForceVector)
          attack.forceVector = this.transform.forward * forceMagnitude;
        flag = attack.Fire();
      }
      return flag;
    }

    public void SmallHop(CharacterMotor characterMotor, float smallHopVelocity)
    {
      if (!(bool) (UnityEngine.Object) characterMotor)
        return;
      characterMotor.Motor.ForceUnground();
      characterMotor.velocity = new Vector3(characterMotor.velocity.x, Mathf.Max(characterMotor.velocity.y, smallHopVelocity), characterMotor.velocity.z);
    }

    protected BaseState.HitStopCachedState CreateHitStopCachedState(
      CharacterMotor characterMotor,
      Animator animator,
      string playbackRateAnimationParameter)
    {
      BaseState.HitStopCachedState hitStopCachedState = new BaseState.HitStopCachedState()
      {
        characterVelocity = new Vector3(characterMotor.velocity.x, Mathf.Max(0.0f, characterMotor.velocity.y), characterMotor.velocity.z),
        playbackName = playbackRateAnimationParameter
      };
      hitStopCachedState.playbackRate = animator.GetFloat(hitStopCachedState.playbackName);
      return hitStopCachedState;
    }

    protected void ConsumeHitStopCachedState(
      BaseState.HitStopCachedState hitStopCachedState,
      CharacterMotor characterMotor,
      Animator animator)
    {
      characterMotor.velocity = hitStopCachedState.characterVelocity;
      animator.SetFloat(hitStopCachedState.playbackName, hitStopCachedState.playbackRate);
    }

    protected void StartAimMode(float duration = 2f, bool snap = false) => this.StartAimMode(this.GetAimRay(), duration, snap);

    protected void StartAimMode(Ray aimRay, float duration = 2f, bool snap = false)
    {
      if ((bool) (UnityEngine.Object) this.characterDirection && aimRay.direction != Vector3.zero)
      {
        if (snap)
          this.characterDirection.forward = aimRay.direction;
        else
          this.characterDirection.moveVector = aimRay.direction;
      }
      if ((bool) (UnityEngine.Object) this.characterBody)
        this.characterBody.SetAimTimer(duration);
      if (!(bool) (UnityEngine.Object) this.modelLocator)
        return;
      Transform modelTransform = this.modelLocator.modelTransform;
      if (!(bool) (UnityEngine.Object) modelTransform)
        return;
      AimAnimator component = modelTransform.GetComponent<AimAnimator>();
      if (!((bool) (UnityEngine.Object) component & snap))
        return;
      component.AimImmediate();
    }

    protected bool RollCrit() => (bool) (UnityEngine.Object) this.characterBody && (bool) (UnityEngine.Object) this.characterBody.master && Util.CheckRoll(this.critStat, this.characterBody.master);

    protected Transform FindModelChild(string childName)
    {
      ChildLocator modelChildLocator = this.GetModelChildLocator();
      return (bool) (UnityEngine.Object) modelChildLocator ? modelChildLocator.FindChild(childName) : (Transform) null;
    }

    protected T FindModelChildComponent<T>(string childName)
    {
      ChildLocator modelChildLocator = this.GetModelChildLocator();
      return (bool) (UnityEngine.Object) modelChildLocator ? modelChildLocator.FindChildComponent<T>(childName) : default (T);
    }

    protected GameObject FindModelChildGameObject(string childName)
    {
      ChildLocator modelChildLocator = this.GetModelChildLocator();
      return (bool) (UnityEngine.Object) modelChildLocator ? modelChildLocator.FindChildGameObject(childName) : (GameObject) null;
    }

    protected bool isGrounded => (bool) (UnityEngine.Object) this.characterMotor && this.characterMotor.isGrounded;

    public TeamIndex GetTeam() => TeamComponent.GetObjectTeam(this.gameObject);

    public bool HasBuff(BuffIndex buffType) => (bool) (UnityEngine.Object) this.characterBody && this.characterBody.HasBuff(buffType);

    public bool HasBuff(BuffDef buffType) => (bool) (UnityEngine.Object) this.characterBody && this.characterBody.HasBuff(buffType);

    public int GetBuffCount(BuffIndex buffType) => !(bool) (UnityEngine.Object) this.characterBody ? 0 : this.characterBody.GetBuffCount(buffType);

    public int GetBuffCount(BuffDef buffType) => !(bool) (UnityEngine.Object) this.characterBody ? 0 : this.characterBody.GetBuffCount(buffType);

    protected void AttemptToStartSprint()
    {
      if (!(bool) (UnityEngine.Object) this.inputBank)
        return;
      this.inputBank.sprint.down = true;
    }

    protected HitBoxGroup FindHitBoxGroup(string groupName)
    {
      Transform modelTransform = this.GetModelTransform();
      if (!(bool) (UnityEngine.Object) modelTransform)
        return (HitBoxGroup) null;
      HitBoxGroup hitBoxGroup = (HitBoxGroup) null;
      List<HitBoxGroup> objectComponents = GetComponentsCache<HitBoxGroup>.GetGameObjectComponents(modelTransform.gameObject);
      int index = 0;
      for (int count = objectComponents.Count; index < count; ++index)
      {
        if (objectComponents[index].groupName == groupName)
        {
          hitBoxGroup = objectComponents[index];
          break;
        }
      }
      GetComponentsCache<HitBoxGroup>.ReturnBuffer(objectComponents);
      return hitBoxGroup;
    }

    protected struct HitStopCachedState
    {
      public Vector3 characterVelocity;
      public string playbackName;
      public float playbackRate;
    }
  }
}